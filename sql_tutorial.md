# SQL туториал

#### Подготовил: Сережа

## Создаем таблицы

Создавать таблицы очень просто, для этого нужно на прямую сказать базе что мы хотим таблицу для этого воспользуемся
командой create table Тут_ваше_название (поля_и_их_типы)

```sql
CREATE TABLE employees
(
    id          integer primary key autoincrement,
    first_name  varchar(255) not null,
    second_name varchar(255) not null,
    hire_date   date,
    fire_date   date default null
);
```

Пока в описании много чего непонятного, особенно если мы говорим про типы данных. Я постараюсь кратенько описать
основные типы и как их использовать

Тип данных  | За что отвечает | Для чего использовать
------------- | ------------- | -----
integer  | целые числа | Храним обычные цифры, подходит для id
DOUBLE  | Числа с плавающей запятой | Храним деньги и все что не целое
VARCHAR(n)  | Строки длинной n символов | Храним не длинные строки
TEXT  | Большие строки | Тут уже можно хранить тексты песен русского рэпа
DATE  | Даты | Даты в днях в формате например '2021-02-12'
DATETIME  | Дата и время | Дата и время в формате например '2021-02-12 14:32:03'
NULL  | Ничего | Отдельные поля с ним создавать не надо, он нужен если какие-то поля могут быть пустыми

Если у вас есть столбец который может быть пустым как в случае с примером выше у нас там поле fired_date то можно задать
ему значение по умолчанию.

Если у вас есть такой столбец который всегда обязан быть заполнен то для него уже можно поставить not null

параметр **primary key** это первичный ключ который позволяет отличать записи одни от других, но похожих. По хорошему он
нужен всегда и он может быть только один (это важно)

## Добавляем данные

Добавление данных это оч простая процедура, для примера давайте вставим данные в нашу таблицу

```sql
INSERT INTO employees (first_name, second_name, hire_date)
VALUES ("Сережа", "Уфимцев", "2020-11-24"),
       ("Петя", "Островский", "2020-02-25"),
       ("Андрюша", "Степанов", "2019-09-03"),
       ("Антоша", "Смирнов", "2021-07-16"),
```

Как видите мы наняли меня, и не заполнили все поля и вот почему:

1. Поле **id** заполнять не нужно как правило субд сама ставит id для записей
2. Поле **fire_date** мы не заполнили потому что меня только наняли и даты увольнения нет физически

В общем по синтаксису мы указываем название таблицы, поля которые хотим добавить и значения в том же порядке в каком у
нас идут поля

## Обновление данных

Логика такая:

```sql
UPDATE employees
SET fire_date='2022-05-01'
WHERE id = 1;
```
Тут мы задаем мне дату увольнения Обратите внимание на условие **WHERE** в нем мы задаем условие по которому будут выбраны записи для обновления
Как можно понять обновить можно не только одну запись а много за раз

## Удаление данных
Рассмотрим пример
```sql
DELETE FROM employees WHERE id = 1;
```
Тут схожая механика с update ибо мы тоже указываем условие для выбора записей через **WHERE** и удаляем все записи какие попали

## Делаем запросы
Теперь пошла самая главная часть это запросы

Самый простой запрос выглядит так:
```sql
SELECT * FROM employees;
```
С этим запросом мы вытаскиваем всю душу из таблицы и на очень больших хранилищах не стоит строить такие запросы,
но для учебного примера она подходит более чем идеально

Немного усложним запрос
```sql
SELECT first_name, hire_data FROM employees WHERE first_name='Сережа';
```
Тут мы явно указали список полей которые мы хотим достать и добавили особое условие что нам нужен именно Сережа

### Лайки и сложные условия
если в строке нужно искать не конкретное значение а подходящее под какое-то условие, мы можем воспользоваться оператором like
```sql
SELECT first_name, hire_data FROM employees WHERE first_name like '%ша%';
```
Этим запросом мы выбираем всех сотрудников у кого в имени есть *ша*
знак процента в начале запроса означает что перед ша может быть сколько угодно символов,
второй же знак процента говорит что после ша тоже может быть сколько угодно символов

Теперь рассмотрим комбирированные условия, из описания понятно что речь идет о том что мы можем использовать несколько условий и их комбинировать

Для комбинирования тут все как в Алгебре логики AND OR XOR NOT

Рассмотрим пример:
```sql
SELECT first_name, hire_data FROM employees WHERE hire_date >= '2020-01-01' AND first_name like 'A%' ;
```
Тут мы выбираем всех сотрудников чье имя начинается на А и кто устроился 1 января 20 года или позже

Еще мы можем использовать скобочки что бы дополнительно групировать условия
```sql
SELECT first_name, hire_data FROM employees WHERE (first_name = 'Сережа' OR first_name = 'Петя') AND hire_date BETWEEN '2020-01-01' AND '2020-06-01';
```
В этом запросе мы выбираем тех кого зовут Сережа или Петя и кто устроился в период с 1 января 20 года по 1 июня

Обратите внимание на слово **BETWEEN** оно позволяет выбирать между диапазоном значений, в примере мы используем 2 даты 
и выбираем между ними

## Гупировки и агрегации
Для объяснения групировок, добавим немного данных
```sql
INSERT INTO employees (first_name, second_name, hire_date)
VALUES ("Иван", "Бацуев", "2015-08-08"),
       ("Иван", "Воронков", "2017-10-04"),
       ("Лев", "Стоянов", "2020-06-13"),
       ("Никита", "Стонов", "2020-06-13"),
       ("Кирилл", "Карапов", "2017-10-04"),
```
А теперь посчитаем число сотрудников которые вышли в опредленный день на работу

```sql
SELECT hire_date, count(*) FROM employees GROUP BY hire_date;
```

В резульатте мы сгрупировали данные и посчитали количество строк внутри каждой агрегации
### Виды агрегаций
Название | Что делает
------------- | -------------
DISTINCT  | Только уникальные значения поля
count() | Считает число строк 
AVG() | Среднее значение
MIN()  | Минимальное значение
MAX()  | Максимальное значение

## Соедиения
### JOIN
### WHERE AND HAVING
### Виды связей

## Нормальные формы
### "единственная" нормальная
### Вторая
### Третья
### Третья с половиной

## Ответы на впросы которые были в презентации, но я не стал подробно расписывать

###Транзакционные и аналитические данные, слои обработки и хранения данных
Для начала дадим определение транзакции, транзакция это некоторый набор операций который может выполниться только целиком 
или не выполниться вообще.

Для большего понимания приведу пример: Представьте что вы переводите кому-то деньги через сбербанк
Для перевода денег нужно:
1. Проверить ваш баланс
2. Проверить адресс получателя
3. Снять сумму с вашего счета
4. Пополнить баланс получателя

А теперь предположим, что в злые агенты ЦРУ выключили свет во всей стране, и банк успел выполнить пункт 3 но еще не начислил деньги получателю
Собственно если бы небыло транзакций то при включении света вы бы обнаружили что у вас пропали деньги, а получателю деньги не пришли
В то время как если бы все выполнялось в рамках одной транзакции, то банк все откатил бы назад ибо транзакция не была закончена, а значит данные не записались

Аналитические данные как я понимаю это речь про субд где хранятся данные для аналитики, хз что тут сказать, ну как правило там нет транзакций, поэтому в них в основном выгружают из транзакционных баз

Слои обработки и хранения данных:
Мне лень было смотреть лекцию но как я понимаю тему речь идет про то что как правило у нас в любой системе аналитики есть следующие слои:

1. Слой с грязными данными
2. Data Warehouse где хранятся очищенные данные (Убрали дубли, и не валидные строки)
3. Витрины данных (Это готовые таблицы в них как правило собираются данные из нескольких таблиц в одну большую, красивую)


### Процедуры для автоматического исполнения загрузок\выгрузок
Ну как я понял по лекции речь идет про crontab и скрипитки на питоне которые что-то там выгружают.
Да это полезная тема, но в нормальных компаниях обычно для этого есть полноценные ETL инструменты

Суть метода:
1. Пишем скриптик на питоне
2. Пишем crontab конфиг где настравиваем параметры и частоту запуска
3. ????
4. Profit
